# 🖥 운영체제

## 📒 About Operation System
### 운영체제
- **개념**
  - 운영체제는 컴퓨터 시스템의 자원들을 효율적으로 관리하는 시스템 소프트웨어이다.
  - 사용자와 다른 모든 소프트웨어 및 하드웨어를 연결하는 매개체 역할을 수행한다.
  - 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있는 환경을 제공한다.
- **용어**
  - **Multi Tasking**
    - 운영체제의 스케줄링을 통해서 작업을 번갈아가며 수행하는 것을 뜻한다.
    - 여러 개의 작업을 빈번하게 번갈아가며 수행하기 때문에 사용자의 입장에서는 동시에 여러 개의 작업을 수행하고 있다고 느끼게 해준다.
  - **Multi Programming**
    - 여러 개의 프로그램을 메모리에 동시에 적재해서 실행시키는 것을 뜻한다.
    - 입출력 작업이 완료될 때까지 대기하는 동안 다른 프로그램을 실행해서 CPU 사용 효율을 높이는 방법이다.
  - **Multi Processing**
    - 여러 개의 프로세서가 다수의 작업을 함께 처리해서 작업 효율을 향상시키는 것을 뜻한다.
    - 멀티 프로세싱은 하나의 프로세서에 문제가 생기더라도 다른 프로세서가 진행중인 작업을 이어서 수행할 수 있기 때문에 작업이 멈추지 않는다는 장점이 있다.
  - **Multi Threading**
    - 하나의 프로세스를 여러 개의 스레드로 구분해서 하나의 프로그램을 병렬 처리하는 것을 뜻한다.
    - 프로세스를 생성하는 비용보다 스레드를 생성하는 비용이 훨씬 적은 자원을 소모하기 때문에 자원 관리 측면에서 더 효율적이다.
    - 프로세스는 영역을 서로 공유하지 않지만 스레드는 스택 영역을 제외한 데이터, 힙 영역을 공유하기 때문에 메모리 관리 측면에서 더 효율적이다.
- **System Call**
- **Interrupt**

## 📕 About Process
### 프로세스
- **개념**
  - 프로그램은 디스크 내에 저장된 실행 파일이다.
  - 프로세스는 메모리에 적재돼서 CPU의 시스템 자원을 할당받아 실행중인 프로그램을 말한다.
  - 자원을 할당받은 프로그램은 여러 개의 프로세스로 파생될 수 있으며 각각 인스턴스를 가진다.

- **구조**
<img src="https://blog.kakaocdn.net/dn/Se5G2/btrGg0NmXKf/0YMyaRF2Z0duUfSvGlmpIK/img.png">

- **구성 요소**
  - **Stack**
    - 함수를 호출할 때마다 사용되는 데이터를 임시로 저장하는 공간이다.
    - Stack 영역은 위에서 아래 방향으로 데이터를 저장해나간다.
  - **Heap**
    - 프로그램을 실행하는 중에 메모리를 동적으로 할당하는 공간이다.
    - Heap 영역은 아래에서 위 방향으로 데이터를 저장해나간다.
  - **Data**
    - 전역 변수를 저장하는 공간이다.
    - 처음부터 크기가 고정되어 있으며, 프로세스를 실행하는 동안 바뀌지 않는다.
  - **Code**
    - 실행 코드가 저장되는 공간이다.
    - 처음부터 크기가 고정되어 있으며, 프로세스를 실행하는 동안 바뀌지 않는다.

- **PCB (Process Control Block)**
  - **개념**
    - PCB는 운영체제가 각 프로세스를 제어하고 관리하기 위한 프로세스의 상태 정보 저장공간이다.
  - **정보**
    - PID
    - Process State
    - Program Counter
    - CPU 레지스터 정보
    - CPU 스케줄링 정보
    - 메모리 관리 정보
    - I/O 상태 정보
    - 계정 정보
- **Context Switching**
  - **개념**

    <img src="https://blog.kakaocdn.net/dn/cuQMPg/btrGC8iiHDH/tqJ4UxDLOz8mCpwjAbOfs0/img.png">

    - 프로세스를 교환하는 작업 또는 PCB를 교환하는 작업을 의미한다.
    - 프로세스에 할당된 시간을 모두 사용해서 **Timeout**이 발생했거나, **Interrupt**가 발생했을 때 이뤄진다.
      - 처리기에 현재 프로세스가 아닌 다른 프로세스가 할당되는 경우에만 **Context Switching**이 발생한다.
      - 따라서 **Interrupt**, **System Call**이 발생했다고 해서 반드시 **Context Switching**이 이뤄지는 것은 아니다.
    - 스케줄러가 처리기에 다른 프로세스를 할당하려고 할 때, 현재 프로세스의 상태를 해당 프로세스의 PCB에 저장하고 새로운 프로세스의 PCB로 교체하는 방식이다.
  - **Overhead**
    - 오버헤드는 Context Switching에 사용된 시간과 메모리를 의미한다.
    - Context Switching이 자주 발생할수록 오버헤드가 발생하기 때문에 성능이 저하된다.
    - 프로세스 P0가 Excuting 상태에서 Idle 상태로 변경될 때, 프로세스 P1이 곧바로 Excuting 상태로 바뀌지 않고 Idle 상태에서 좀 더 머물러있다가 Excuting 상태로 변경된다.
      - 프로세스 P0를 PCB에 저장하고, 프로세스 P1의 상태를 PCB에서 가져와야 하기 때문이다.
      - 처리기는 PCB에 상태를 저장하고 가져올 때 어떠한 일도 수행할 수 없게 되고, 이런 상황이 자주 발생할수록 성능 저하로 이어지게 된다.
  - **Process vs Thread**
    - 스레드는 Stack 영역을 제외한 Code, Data, Heap 영역을 공유하기 때문에 Stack 영역만 교체해주면 되므로 사용되는 비용이 적다.
    - 하지만 프로세스는 Code, Data, Heap, Stack 영역을 모두 교체해줘야하기 때문에 스레드에 비해서 사용되는 비용이 많다.

- **프로세스 상태 전이 다이어그램**
<img src="https://blog.kakaocdn.net/dn/4J1kG/btrGB3O7Zjm/A4KyWUnKHBkvtppbKdsrpK/img.png">

- **프로세스 상태**
  - **New**
    - 프로세스가 처음 생성됨과 동시에 커널 공간에 PCB가 함께 생성된다.
  - **Ready**
    - 프로세스가 처리기에 할당될 때까지 기다리는 상태를 말한다.
    - 메모리에 적재돼서 실행에 필요한 자원을 모두 얻은 상태이다.
    - Ready 상태를 가지는 여러 개의 프로세스가 존재할 수도 있다.
  - **Running**
    - 프로세스가 처리기에 할당돼서 명령어를 실행중인 상태를 말한다.
  - **Waiting**
    - I/O 또는 이벤트가 발생할 때까지 기다리는 상태를 말한다.
  - **Terminated**
    - 프로세스의 실행이 완료되고 PCB를 파괴한다.

- **프로세스 상태 전이**
  - **Admitted (New → Ready)**

  - **Schedular Dispatch (Ready → Running)**

  - **Interrupt (Running → Ready)**

  - **I/O or Event Wait (Running → Waiting)**

  - **I/O or Event Completion (Waiting → Ready)**

- **Schedular**
  - **Short-Term Schedular (CPU Schedular)**
    - 어떤 프로세스를 다음에 실행시킬지 선택하고 처리기에 프로세스를 할당한다.
  - **Long-Term Schedular (Job Schedular)**
    - 시작 프로세스 중에서 어떤 프로세스를 Ready Queue로 보낼지 결정하고, 프로세스에 메모리 및 각종 자원을 할당한다.
    - Time-Shaing 시스템에서는 보통 장기 스케줄러 없이 무조건 Ready Queue에 추가하는 방식을 사용한다.
  - **Medium-Term Schedular (Swapper)**
    - 프로세스를 메모리에서 디스크로 쫓아내서 여유 공간을 마련하는 **Swapping** 작업을 담당한다.

## 📙 About Process Scheduling
### **비선점 스케줄링**
- **개념**

### **선점 스케줄링**
- **개념**

## 📗 About Process Synchronization
### 동기화
- **개념**
  - 프로세스 간에 실행 순서 및 규칙을 정해서 데이터의 일관성을 보장하는 개념을 말한다.
  - 공유 자원에 대한 동시 접근으로 인해 발생하는 데이터 불일치 문제를 막고 일관성을 유지하기 위해서 사용한다.
- **Race Condition**
  - 여러 개의 프로세스 또는 스레드가 데이터를 동시에 접근할 때, 어떤 순서로 데이터를 접근하는지에 따라 결과가 달라질 수 있는 상황을 경쟁 조건이라고 한다.
- **Critical Section**
  - **개념**
    - 경쟁 조건이 공유 자원을 접근하는 코드가 존재하는 영역을 임계 구역이라고 한다.
  - **파생되는 문제 해결 조건**
    - **Mutual Exclusion**
      - 하나의 프로세스가 임계 구역에서 작업중이면 다른 프로세스 임계 구역에 접근할 수 없어야 한다.
    - **Progress**
      - 임계 영역에서 작업중인 프로세스가 없으면 임계 영역에 진입하려는 프로세스는 임계 영역에 접근할 수 있어야 한다.
    - **Bounded Waiting**
      - 프로세스가 임계 영역에 들어가기 위해 요청한 시점부터 요청이 허용될 때까지 다른 프로세스들이 임계 영역에 진입하는 횟수를 제한해야 한다.
      - 다시 말해서 임계 영역에 진입하려는 프로세스가 무한정 기다리는 Starvation이 발생해서는 안된다는 뜻이다.

### 동기화 도구들
- **Mutex (Mutual Exclusion)**
  - 자원에 대한 접근을 동기화하기 위해 사용되는 상호 배제 기술이다.
  - 한 번에 하나의 프로세스만 임계 영역에 진입할 수 있도록 하는 **Locking** 메커니즘을 따른다.
    - 오직 자원을 획득해서 Lock을 걸은 스레드만 임계 영역을 빠져나갈 때 Lock을 해제할 수 있다.
  - Spin-Lock과 달리 Busy Waiting 상태를 유지하지 않고 Sleep 상태로 들어간 후 WakeUp 상태로 바뀌면 다시 권한 획득을 시도하는 **Sleep Lock**을 사용한다.
- **Spin-Lock**
  - 임계 영역의 Lock이 풀려서 접근 권한을 얻을 때까지 루프를 돌면서 재시도하는 방식으로 구현된 Lock이다.
  - Mutex와 동일하게 상태가 **Lock**과 **Unlock**만 존재하기 때문에 한 번에 하나의 컴포넌트만 접근할 수 있다.
  - 임계 구역에 진입하기 전까지는 계속 루프를 돌고 있기 때문에 **Busy Waiting** 상태를 유지하게 된다.
    - Busy Waiting은 작업을 수행하지 않고 자원을 사용하면서 계속 대기하는 상태를 말한다.
  - Spin-Lock은 운영체제의 스케줄링 지원을 받지 않기 때문에 Context-Switching이 발생하지 않는다.
    - 단일 CPU 환경에서는 Context-Switching이 발생하지 않으므로 멀티 프로세서 시스템에서만 사용된다.
    - Context-Switching 비용이 들지 않기 때문에 단시간에 진입할 수 있으면 효율을 높일 수 있지만, 반대의 경우에는 다른 스레드에게 자원을 양보하지 않고 점유하기 때문에 처리 효율이 저하된다.
- **Semaphore**
  - **개념**
    - 여러 프로세스 또는 스레드가 임계 영역에 진입할 수 있는 **Signaling** 메커니즘을 따른다.
    - Mutex 또는 Spin-Lock과 달리 하나 이상의 스레드가 공유 자원에 접근하도록 만들 수 있다.
    - 정수형으로 표현하기 때문에 Lock 또는 Unlock이 아닌 값을 증가시키고 감소시키는 방식을 사용한다.
  - **종류**
    - Binary Semaphore
      - 정수 값으로 0과 1만 사용할 수 있으며 Mutex Lock과 동일한 역할을 수행한다.
    - Counting Semaphore
      - 정수 값의 범위가 0 이상으로 자원 개수에 제한이 없고, 주로 자원의 개수를 세는데 사용한다.
      - 자원을 획득하면 Semaphore가 감소하고 해제하면 Semaphore가 증가한다.
- **Mutex vs Semaphore**
  - Mutex는 오직 하나의 스레드만 접근할 수 있는 반면에 Semaphore는 여러 개의 스레드가 접근할 수 있다.
  - Mutex는 자원을 획득하고 해제하는 주체가 반드시 동일해야 하지만 Semaphore는 현재 수행중인 스레드가 아닌 다른 스레드도 Signal을 통해서 Lock을 강제로 해제할 수 있다.

### 교착상태 (Deadlock)
- **개념**
  - 교착상태는 둘 이상의 프로세스들이 자원을 점유한 상태에서 다른 프로세스의 자원을 요구하며 무한정 기다리는 현상을 말한다.
- **교착상태가 발생하기 위한 4가지 필요충분조건**
  - **상호 배제 (Mutual Exclusion)**
    - 한 번에 하나의 프로세스만 공유 자원을 사용할 수 있는 상황을 말한다.
  - **점유와 대기 (Hold and Wait)**
    - 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있는 상황을 말한다.
  - **비선점 (Non-preemption)**
    - 다른 프로세스에 할당된 자원을 사용이 끝날 때까지 강제로 선점하지 못하는 상황을 말한다.
  - **환형 대기 (Circular Wait)**
    - 자원을 기다리는 프로세스 간에 사이클이 형성되는 상황을 말한다.
    - ex. 프로세스 p0는 p1을 기다리고, p1은 p2를 기다리고, ... , pn은 p0를 기다린다.
- **교착상태를 해결하기 위한 4가지 해결방법**
  - **예방 (Prevention)**
    - 교착상태가 발생하기 위한 4가지 조건 중에 하나를 제거해서 해결하는 방식이다.
  - **회피 (Avoidance)**
    - 교착상태가 발생하지 않도록 알고리즘을 적용해서 자원을 할당하지 않는 방식이다.
    - 교착상태를 해결하기 위한 알고리즘으로 자원 할당 그래프 알고리즘과 은행원 알고리즘이 있다.
  - **탐지 & 회복 (Detection & Recovery)**
    - 시스템에 교착상태가 발생했는지 점검해서 교착상태에 있는 프로세스와 자원을 발견하고 교착상태를 일으킨 프로세스를 종료하거나 할당된 자원을 다른 프로세스에게 할당해서 해결하는 방식이다.
- **교착상태 무시 (Ignorance)**
    - 교착상태가 발생하지 않는다고 가정하고 어떠한 조치도 취하지 않는 방식이다.
    - 교착상태에 의한 성능 저하보다 이를 해결하기 위한 Context-Switching으로 발생하는 오버헤드로 인해 성능 저하가 더 클 경우에 무시하는 방식이다.

## 📘 About Memory Management
### Main Memory
- **Fragmentation**
  - **개념**
    - 프로세스를 메모리에 적재하고 제거하는 작업이 반복되면서 프로세스들이 차지하는 메모리 공간 사이에 적재하지 못하는 작은 공간이 생성되는 현상이다.
    - 단편화가 일어날수록 메모리에 적재할 수 있는 프로세스가 적어지기 때문에 메모리 낭비가 발생한다.
  - **내부 단편화**
    - 프로세스가 사용하는 메모리 공간보다 분할된 공간이 더 커서 할당할 수 있는 메모리 공간이 남는 단편화를 말한다.
  - **외부 단편화**
    - 메모리 내부에 크기가 작은 빈 공간이 많아지면서 다른 프로세스를 적재할 수 없게 되는 단편화를 말한다.
    - 프로세스를 수용할 수 있는 충분한 메모리 공간이 있음에도 불구하고 연속적으로 이어져있지 않아서 발생한다.
  - **압축 (Compaction)**
    - 외부 단편화를 해결하기 위해 프로세스가 사용하는 공간을 한쪽으로 몰아서 공간을 확보하는 방법이다.
    - 저장장치에 메모리를 복사하는 과정에서 발생하는 I/O 문제와 메모리를 이동시키는 과정에서 발생하는 오버헤드 때문에 사용하기 어렵다.
- **Contiguous Memory Allocation**
  - **개념**
    - 전체 프로세스를 하나의 메모리 공간에 연속적으로 적재하는 방식이다.
  - **Fixed Partitioning**
    - **개념**
      - 메모리를 고정된 크기로 분할해서 각각 분할한 메모리 공간에 프로세스를 하나씩 적재하는 방식이다.
    - **문제점**
      - 내부 단편화와 외부 단편화가 모두 발생하기 때문에 메모리 낭비가 많다.
        - 프로세스의 크기가 분할 크기에 정확하게 맞지 않으면 내부 단편화가 발생한다.
        - 분할 크기가 너무 작아서 프로세스를 적재할 수 없으면 외부 단편화가 발생한다.
      - 동시에 메모리에 적재할 수 있는 프로세스의 수가 고정되며, 수행 가능한 프로세스의 최대 크기가 제한된다.
  - **Dynamic Partitioning**
    - **개념**
      - 프로세스의 크기에 맞게 메모리를 동적으로 분할해서 각각 적재하는 방식이다.
      - 프로세스에 알맞게 메모리 공간을 할당하기 때문에 내부 단편화가 발생하지 않는다.
    - **배치 알고리즘**
      - **First-Fit**
        - 메모리를 순차적으로 탐색하여 가장 먼저 발견한 가용 메모리 공간에 프로세스를 적재하는 방법이다.
        - 모든 가용 메모리 공간을 탐색하지 않기 때문에 다른 방법들에 비해 속도가 빠르다.
      - **Best-Fit**
        - 메모리를 탐색하여 프로세스의 크기와 가용 메모리 공간의 차이가 가장 적은 곳에 프로세스를 적재하는 방법이다.
        - 프로세스가 할당될수록 차이가 가장 적은 곳을 찾기 위해서 메모리를 탐색하는데 걸리는 시간이 길어지기 때문에 속도가 느리다.
      - **Worst-Fit**
        - 메모리를 탐색하여 프로세스의 크기와 가용 메모리 공간의 차이가 가장 큰 곳에 프로세스를 적재하는 방법이다.
    - **문제점**
      - 사용중인 프로세스가 종료돼서 메모리에 새로운 프로세스를 적재할 메모리 공간이 충분하지 않다면 외부 단편화가 발생한다.
- **Non-Contiguous Memory Allocation**
  - **개념**
  - **Paging**
    - 프로세스를 일정한 크기인 페이지로 분할해서 메모리에 적재하는 비연속적 할당 방식을 말한다.
    - 외부 단편화를 해결할 수 있지만 내부 단편화가 발생한다.
  - **Segmentation**
    - 

### Virtual Memory
- **Swapping**
  - **개념**
    - Swap-In, Swap-Out을 통해서 주기억장치에 적재된 프로세스를 교체하는 작업이다.
    - 메모리 공간이 부족할 때 스와핑 작업이 이뤄진다.
  - **Swap In**
    - 다른 프로세스를 메모리에 적재하는 작업이다.
  - **Swap Out**
    - CPU 할당 시간이 끝난 프로세스를 보조기억장치로 내보내는 작업이다.
### Cache Memory