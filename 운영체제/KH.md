# **운영체제**

## **운영체제란?**

컴퓨터 하드웨어가 컴퓨터 소프트웨어와 통신하고 작동하도록하는 소프트웨어 프로그램

## **운영체제의 목적**

1. 컴퓨터 시스템의 계산 활동을 관리하여 컴퓨터 시스템이 제대로 작동하도록 한다.

2. 프로그램 개발 및 실행을 위한 환경을 제공한다.

## **시스템 콜이란?**

시스템콜은 커널과 사용자 사이의 인터페이스 역할을 하는 것으로 **쉘(Shell)**에서 명령어나 서브루틴 형식으로 운영체제의 기능을 호출할 수 있다. 즉, 사용자가 직접 커널에 접근할 수 없기 때문에 시스템콜을 활용해야한다.

보통 시스템 콜을 직접 사용하기보다는, 해당 시스템 콜을 사용해서 만든 각 언어별 라이브러리(API)를 사용한다.

쉽게 말하면 **운영체제의 기능을 호출하는 함수**이다.

## **커널이란?**

운영체제의 핵심적인 부분으로, 파일입출력, 프로세스관리 등과 같이 **운영체제의 기능을 담당**하지만 일반 사용자모드에선 커널에 접근할 수 없기 때문에 원칙적으로는 파일 입출력, 프로세스 생성등 커널의 기능을 사용하지 못한다. 그래서 운영체제에서 제공하는 것이 **시스템 콜**이다.

응용프로그램이 운영체제의 기능을 요청하기 위해서, 운영체제는 **시스템 콜**을 제공한다. (시스템 함수를 호출하는 것이어서 시스템 콜, 운영체제가 제공하는 기능을 사용할 수 있는 api)

## **쉘(Shell)이란?**

운영체제는 쉘을 통해서 사용자 인터페이스를 제공한다.쉘은 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 **인터페이스를 제공하는 프로그램**이다.쉘은 터미널환경(CLI)과 GUI 환경 두 종류로 나뉜다.

## **Byte Ordering이란 ?**

Byte Ordering이란 데이터가 저장되는 순서를 의미합니다. 

Byte Ordering의 방식에는 빅엔디안(Big Endian)과 리틀엔디안(Little Endian)이 있습니다.

- Big Endian
- MSB가 가장 낮은 주소에 위치하는 저장 방식네트워크에서 데이터를 전송할 때 주로 사용됨가장 낮은 주소에 MSB가 저장되므로, offset=0인 Byte를 보면 양수/음수를 바로 파악할 수 있다.
- Little Endian
- MSB가 가장 높은 주소에 위치하는 방식마이크로프로세서에서 주로 사용된다. 가장 낮은 주소에 부호값이 아닌 데이터가 먼저 오기 때문에, 바로 연산을 할 수 있다.

## **프로세스란?**

컴퓨터에서 실행되고 있는 프로그램을 프로세스라고 한다.

두 가지 유형의 프로세스가 있다. 운영 체제 프로세스, 사용자 프로세스

## **프로세스의 특징**

- 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.
- 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다. (Ex. 파이프, 파일, 소켓 등을 이용한 통신 방법 이용)

## **IPC (InterProcess Communication)**

프로세스는 독립적으로 실행된다. 독립되어있다는 것은 다른 프로세스에게 영향을 받지 않는다는 것 (메모리공간이 독립되어있다. 스레드는 프로세스 안에서 자원을 공유하므로 다른 스레드의 영향을 받는다.)

이런 독립적 구조를 가진 **프로세스간의 통신**을 해야하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 IPC 통신이다.

프로세스는 **커널**이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있다.

## **스레드(Thread)란?**

스레드는 CPU 사용의 기본 단위이다. 프로세스 내에서 실행되는 여러 흐름의 단위를 말한다.

스레드는 스레드 ID, 프로그램 카운터, 레지스터 세트 및 스택으로 구성된다.

[참고] 운영체제는 자원을 효율적으로 사용하려고 한다. 스레드를 사용하면 프로세스보다 생성할 때 오버헤드도 적고 공유된 자원에 대해서도 오버헤드가 적다. 그리고 스레드를 이용하면 병렬성을 높일 수 있다.

## **스레드의 특징**

- 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
- 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.

## **프로세스와 스레드의 차이**

프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고, 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위 이다. 프로세스는 운영체제로부터 메모리, 주소 공간 등을 할당받고 쓰레드는 할당받은 자원들을 내부 스레드끼리 공유하면서 실행된다.

[정리]

- 프로세스는 실행 중인 프로그램으로 다른 프로세스와 상관없이 독립적으로 자원을 할당 받는다.
- 스레드는 경량화된 프로세스로 프로세스 안에 존재한다. 각 스레드는 별도의 레지스터와 스택을 갖고, 힙 영역은 공유한다.

스레드를 사용하는 이유는 운영체제에서 더 효율적으로 시스템 자원을 관리하기 위해 사용된다고 할 수 있다. 멀티 프로세스로 진행되는 작업을 멀티 쓰레드로 수행하게 되면 시스템 콜이 줄어들기 때문에, 자원을 효율적으로 관리 할 수 있고 프로세스의 통신비용보다 쓰레드간의 통신 비용이 적다는 이점도 있다.

단 스레드간의 자원공유는 전역변수를 이용하므로 동기화 문제에 신경을 써야하며 멀티스레드 프로그래밍은 프로그래머의 주의를 요구한다.

![https://velog.velcdn.com/images%2Fsyleemk%2Fpost%2Fff7b9fa7-5af5-4e0c-9f17-8d399531d78b%2Fimage.png](https://velog.velcdn.com/images%2Fsyleemk%2Fpost%2Fff7b9fa7-5af5-4e0c-9f17-8d399531d78b%2Fimage.png)

## **스레드의 장점**

- 스레드는 프로세스보다 생성 및 종료시간, 스레드간 전환시간이 짧다.
- 스레드는 프로세스의 메모리, 자원등을 공유하므로 커널의 도움없이 상호간의 통신이 가능하다.

## **멀티 스레딩(Multi-threading) 의 장점과 단점**

- 멀티 스레딩이란 하나의 프로세스를 다수의 스레드로 만들어 실행하는 것

장점)

- 하나의 프로세스 내에 다수의 실행 단위들이 존재하여 작업의 수행에 필요한 자원들을 공유하기 때문에 자원의 생성과 관리가 중복되는 것을 줄일 수 있다.
- 문맥 전환이 빠르다는 장점

단점)

- 교착상태를 발생시킬 수 있다.
- 동기화에 주의해야한다.

## **멀티 쓰레드의 동시성과 병렬성**

- 동시성은멀티 작업을 위해 싱글 코어에서 여러 개의 쓰레드가 번갈아 실행하는 것을 말합니다.(동시에 실행하는 것처럼 보이지만 사실은 번갈아가며 실행하고 있는 것임)
- 병렬성은 멀티 작업을 위해 멀티 코어에서 한 개 이상의 쓰레드를 포함하는 각 코어들을 동시에 실행하는 것을 말합니다.

## **멀티 프로세스 대신 멀티 스레드를 사용하는 이유**

- 쉽게 설명하면, 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이다.
- 자원의 효율성 증대
    - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다. (프로세스 간의 Context Switching시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 때문)
    - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
- 처리 비용 감소 및 응답 시간 단축
    - 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다. (스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문)
    - 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다. (Context Switching시 스레드는 Stack 영역만 처리하기 때문)

## **문맥 교환(Context Switching)이란?**

프로세스 상태를 변경하는 것을 말한다. 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업이다. 즉, 스케줄링에 의해 실행 중인 코드, 자원 등을 저장하고 현재 상태를 대기 상태로 만들고, 다른 프로세스를 실행시키는 과정

## **멀티 프로세싱과 멀티프로그래밍의 차이**

멀티 프로세싱은 여러개의 처리장치(CPU)를 장착하여 동시에 여러 작업을 병렬로 실행하는 방법.

멀티 프로그래밍은 다수 개의 프로그램의 같이 주기억장치에 있도록 한 방식.

## **CPU 스케줄링**

CPU를 잘 사용하기 위해 프로세스를 잘 배정하는 것, OS에 의해 일어남

- 조건 : 오버헤드 줄이고 / CPU사용률 높이고 / 기아현상 줄이고
- 목표
    - 배치 시스템 : 가능하면 많은 일을 수행, 시간보단 처리량(throughout)이 중요
    - interactive system : 빠른 응답시간, 적은 대기시간
    - real-time system : 기한(deadline)까지 맞추기

## **선점 / 비선점 스케줄링**

- 선점 (preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
- 비선점 (nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측 어렵다)

![https://velog.velcdn.com/images%2Fsyleemk%2Fpost%2Faa894f50-1518-42cf-b6ce-0aed20ff26c8%2Fimage.png](https://velog.velcdn.com/images%2Fsyleemk%2Fpost%2Faa894f50-1518-42cf-b6ce-0aed20ff26c8%2Fimage.png)

- 비선점 스케줄링 : `Interrupt`, `Scheduler Dispatch`
- 선점 스케줄링 : `I/O or Event wait`

### **프로세스 상태 전이**

- 승인 (Admitted) : 프로세스 생성이 가능하여 승인됨
- 스케줄러 디스패치 (Scheduler Dispatch) : 준비상태에 있는 프로세스중 하나를 선택하여 실행시키는 것
- 인터럽트 (Interrupt) : 예외, 입출력, 이벤트 등이 발생하여 현재 실행중인 프로세스를 준비상태로 바꾸고, 해당 작업을 먼저 처리하는 것
- 입출력 또는 이벤트 대기 (I/O or Event wait) : 실행중인 프로세스가 입출력이나 이벤트를 처리해야하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기상태로 만드는 것
- 입출력 또는 이벤트 완료 (I/O or Event Completion) : 입출력/이벤트가 끝난 프로세스를 준비상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것

## **CPU 스케줄링의 종류**

### **비선점 스케줄링**

- FCFS (First Come First Served)
    - 큐에 도착한 순서대로 CPU 할당
    - 실행시간이 짧은게 뒤로가면 평균 대기시간이 길어진다.
- SJF (Shortest Job First)
    - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
    - FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리

### **선점 스케줄링**

- Priority Sceduling
    - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
    - 우선순위가 낮은 프로세스가 무한정 기다리는 Starvation(기하 현상)이 생길 수 있다.
    - Aging 방법으로 Starvation 문제 해결 가능
- Round Robin
    - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 `Time Quantum`만큼 CPU를 할당받는다.
    - `Time Quantum` or `Time Slice` : 실행의 최소단위 시간
    - 할당시간 (Time Quantum)이 크면 FCFS와 같게되고, 작으면 문맥교환 (Context Switching)이 잦아져서 오버헤드가 증가한다.
- Multilevel Queue (다단계 큐)
    - 작업들을 여러 종류의 그룹으로 나누어 여러개의 큐를 이용하는 기법
    - 우선순위가 낮은 큐들이 실행 못하는 것을 방지하고자 각 큐마다 다른 타임 퀀텀을 설정해주는 방식 사용
    - 우선순위 높은 큐는 작은 타임 퀀텀 할당, 우선순위 낮은 큐는 큰 타임퀀텀 할당

## **데드락 (DeadLock)**

프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하고 무한정 대기하는 상태. 교착상태라고도 부름시스템적으로 한정된 자원을 여러 곳에서 사용하고자 할 때 발생

## **데드락 발생조건**

4가지 모두 성립해야 데드락 발생! (하나라도 성립하지 않으면 데드락 문제 해결 가능)

1. **상호배제 (Mutual Exclusion)**

자원은 한번에 한 프로세스만 사용할 수 있다.

2. **점유 대기 (Hold and Wait)**

최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야한다.

3. **비선점 (Non preemptive)**

다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.

4. **순환대기 (Circular Wait)**

프로세스의 집합에서 순환형태로 자원을 대기하고 있어야한다.

## **데드락 처리**

교착 상태를 **예방 & 회피**

예방

교착 상태 발생 조건 중 하나를 제거하면서 해결 (자원 낭비 심함)

회피

교착 상태 발생시 피해나가는 방법ex) 은행원 알고리즘

## **세마포어**

공유된 자원에 여러 프로세스 혹은 스레드가 동시에 접근하면서 문제가 발생할 수 있다. 이때 공유된 자원의 데이터는 한번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야한다. (상호배제)

이를 위해 나온 것이 바로 **세마포어**이다.

멀티프로그래밍 환경에서 공유자원에 대한 **접근을 제한하는 방법**프로세스 진입 여부를 **자원의 개수**를 통해 결정!

세마포어는 사용 중인 리소스를 잠그는 데 사용되는 보호된 변수 또는 추상 데이터 유형이다. 공유된 자원의 데이터를 여러 '프로세스'에서 접근하는 것을 막는다. 세마포어의 값은 공통 자원의 상태를 나타냅니다. 리소스 상태를 나타내는 간단한 카운터이다. 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할 수 있다.

## **임계구역 (Critical Section)**

여러 프로세스가 데이터를 공유하면서 수행될 때, **각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분**

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야한다. (상호배제)

## **뮤텍스**

임계구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술 - 즉 공유자원에 대한 접근이 동시에 여러 스레드에서 일어나지 않도록 하는 것 = 상호배제

상호 배제 (Mutual Exclusion)의 약자

해당 접근을 조율하기 위해 lock과 unlock을 사용

- lock : 현재 임계구역에 들어갈 권한을 얻어옴 (만약 다른 프로세스/스레드가 임계구역 수행중이면 종료할 때까지 대기)
- unlock : 현재 임계구역을 모두 사용했음을 알림 (대기중인 다른 프로세스/스레드가 임계구역에 진입할 수 있음)

프로세스 혹은 스레드 간의 통신 시에 shared memory 등을 쓰는 경우 하나의 자원에 두 개 이상의 프로세스 혹은 스레드가 접근하는 경우에 문제가 발생한다. 이를 제어하기 위해 스레드는 뮤 텍스를 사용하고, 프로세스에서는 세마포어를 사용한다.

- 뮤 텍스 : 상호 배제라고도 하며, Critical Section을 가진 스레드의 Running Time이 서로 겹치지 않도록 각각 단독으로 실행하게 하는 기술이다. 뮤 텍스는 상태가 0, 1 두 개뿐인 이진 세마포어. synchronized 또는 lock을 통해 해결한다.

## **뮤텍스 세마포어 정리**

세마포어는 자원의 개수로 임계구역 진입조건을 판단하고,뮤텍스는 락과 언락연산을 통해 임계구역 진입 조건을 판단한다.

가장 큰 차이는 동기화 대상의 개수이다. **뮤 텍스는 동기화 대상이 하나**
뿐이고, **세마포어는 동기화 대상이 하나 이상** 일 때.

참고사이트

[https://hyonee.tistory.com/95](https://hyonee.tistory.com/95)

[https://dev-coco.tistory.com/162](https://dev-coco.tistory.com/162)

[https://mangkyu.tistory.com/92](https://mangkyu.tistory.com/92)

[https://velog.io/@syleemk/면접-대비-운영체제](https://velog.io/@syleemk/%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

[https://minhamina.tistory.com/235](https://minhamina.tistory.com/235)
