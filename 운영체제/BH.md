# 🖥 운영체제
## 📒 About CPU Scheduling
### 스케줄링
- **스케줄러**
  - CPU가 유휴 상태가 될 때마다, 운영체제는 Ready Queue에 있는 프로세스 중에서 하나를 선택해 실행해야 한다. 선택 절차는 CPU 스케줄러(CPU Scheduler)에 의해 수행된다.

- **스케줄링 결정 상황 4가지**
  - 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (I/O 발생)
  - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 (인터럽트 발생)
  - 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 (I/O 종료)
  - 프로세스가 종료할 때

- **비선점 스케줄링**
  - 일단 CPU가 한 프로세스에 할당되면 프로세스가 종료하든지, 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유한다. (1,4번)

- **비선점 스케줄링**
  - 시분할 시스템에서 타임 슬라이스가 소진되었거나, 인터럽트나 시스템 호출 종료시에 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때, 현 실행 프로세스로부터 강제로 CPU를 회수하는 것을 말한다. (2,3번)

- **Dispatcher**
  - CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈
    - 한 프로세스에서 다른 프로세스로 문맥을 교환하는 일
    - 사용자 모드로 전환하는 일
    - 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동(jump) 하는 일

- **스케줄링 기준**
  - CPU 이용률(Utilization): 어느 기간 동안 또는 특정 SNAPSHOT에서의 CPU의 이용률을 말한다.
  - 처리량(Throughput): 단위 시간당 완료된 프로세스의 개수로써 나타낼 수 있다.
  - 총처리 시간(Turnaround Time): 프로세스의 제출 시간과 완료 시간의 간격을 총처리 시간이라고 한다.
  - 대기 시간(Waiting Time): 대기 시간은 프로세스가 준비 큐에서 대기하면서 보낸 시간의 합이다.
  - 응답 시간(Response Time): 하나의 Request를 제출한 후 첫 번째 Response가 나올 때까지의 시간이다.
    - CPU Utilization, Throughput을 최대화하고 Turaround Time, Waiting Time, Response Time을 최소화 하는 알고리즘의 선택이 바람직한 선택이다.

- **스케줄링 알고리즘**
  - FCFS(선입 선처리) : CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
    - FCFS의 부정적인 측면으로는 선입 선처리 정책하에서 평균대기 시간은 종종 대단히 길 수 있다는 점을 갖고 있다. (대화형 시스템에 적절하지 않다.)
  - SJF(최단 작업 우선) :  CPU 버스트 길이가 가장 작은 프로세스부터 순서적으로 CPU 코어를 할당한다.
    - 주어진 프로세스 집합에 대해 최소의 평균대기 시간을 가진다는 점에서 최적임
  - RR(라운드 로빈) : 선입 선처리 스케줄링과 유사하지만 시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된다. 시간 할당량(time quantum), 또는 타임슬라이스(time slice)라고 하는 작은 단위의 시간을 정의한다. CPU 스케줄러는 준비 큐를 돌면서 한 번에 한 프로세스에 한 번의 시간 할당량 동안 CPU를 할당한다.
  - Priority Scheduling(우선순위) : 우선순위가 각 프로세스들에 연관되어 있으며, CPU 코어는 가장 높은 우선순위를 가진 프로세스에 할당된다.
    - 우선순위 스케줄링 알고리즘의 주요 문제는 무한 봉쇄(indefinite blocking) 또는 기아 상태(starvation)이다.
      - blocking : 실행 준비는 되어 있으나 CPU를 사용하지 못하는 프로세스는 CPU를 기다리면서 봉쇄 된 것으로 간주할 수 있다.
      - Starvation : 부하가 과중한 컴퓨터 시스템에서는 높은 우선순위의 프로세스들이 꾸준히 들어와서 낮은 우선순위의 프로세스들이 CPU를 얻지 못하게 될 수 도 있다. 
      - **낮은 우선순위의 프로세스들이 무한히 봉쇄되는 문제에 대한 한가지 해결 방안은 노화(aging)이다. 노화는 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.**

## 📒 About 동기화
### 동기화
- **동기화 란?**
  - 동기화는 프로세스(스레드)가 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하는 것인데, 쉽게 말해 프로세스 간 데이터가 일치하도록 하는 것이다.
  - 이러한 동기화 메커니즘인 상호배제는 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구하는 것이다.
  - 하나의 프로세스가 공유자원을 사용할 때 다른 프로세스가 동일한 공유자원에 접근할 수 없도록 통제하는 것을 뜻한다. 

- **Mutex**
  - 여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 메커니즘이다.

- **Semaphore**
  - 멀티프로그래밍 환경에서 다수의 프로세스나 스레드가 n 개의 공유 자원에 대한 접근을 제한하는 방법으로 사용되는 동기화 기법이다.

- **Synchronized**
  - Java 의 synchronized 키워드는 스레드 동기화를 할 때 사용하는 대표적인 기법이다. 자바의 모든 인스턴스는 Monitor 를 가지고 있으며(Object 내부) Monitor 를 통해 Thread 동기화를 수행한다. synchronized 키워드가 붙은 메서드를 사용하려면 Lock 을 가지고 있어야 한다.
  - synchronized 를 사용하는 방법으로는 메서드 앞에 키워드 명시, 인스턴스로 사용하기가 있다. 동기화가 필요한 메서드 앞에 synchronized 키워드만 붙여주면 편리하게 동기화를 적용할 수 있다. 인스턴스로 사용하려면 메서드 내부에서 synchronized (메서드) { 구현 } 으로 사용할 수 있다.

## 📒 메모리 관리
- **Address Binding**
  - 프로세스의 주소는 논리적 주소와 물리적 주소로 나뉜다.
    - 논리적 주소는 가상 주소라고 하며 CPU가 생성하는 주소이다.(프로세스가 독립적으로 가짐)
    - 물리적 주소는 프로세스가 실행되기 위해 실제로 메모리에 올라가는 위치이다.
  - 즉, Address Binding은 어떤 프로그램이 메모리의 어느 위치에, 즉 어떤 물리적 주소에 load 될지를 결정하는 과정이다.

- **Swapping**
  - 메모리는 크기가 크지 않기 때문에 프로세스를 임시로 디스크에 보냈다가 다시 메모리에 로드해야 하는 상황이 생긴다. 
  - 이때 디스크로 내보내는 것을 swap out, 메모리로 들여보내는 것을 swap in이라고 한다.

- **Contiguous Allocation**
  - 메모리는 일반적으로 커널 영역과 프로세스 영역으로 나뉘어서 사용된다.
  - 프로세스 영역의 할당 방법으로는 연속적 할당, 비연속적 할당으로 나뉜다.
  - Contiguous Allocation 시스템은 말 그대로, 각 프로세스들이 연속적인 메모리 공간을 차지하게 되는 것
    - 고정 분할 : 분할 당 하나의 프로세스가 적재되기 때문에 동시에 메모리에 load 되는 프로세스의 수가 고정된다. 또 수행 가능한 프로세스의 최대 크기가 제한된다. 
    - 가변 분할 : 프로세스의 크기를 고려해서 할당하기 때문에 분할의 크기나 개수가 동적으로 변한다. 이를 위해서는 기술적인 관리 기법이 필요하다.  
   
- **Fragmentation**
  - 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 공간들이 늘어나게 되는 현상
    - 외부 단편화 : 총공간을 계산했을 때 프로세스가 들어갈 수 있는 메모리가 있음에도 불구하고 공간들이 연속하지 않아 사용할 수 없는 경우
    - 내부 단편화 : 프로세스가 사용하는 메모리 공간보다 분할된 공간이 더 커서 메모리가 남는 경우

- **Paging**
  - 외부 단편화의 압축 작업의 비효율성을 해결하기 위한 방법, 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.대신 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있다.
  - 메모리는 프레임(Frame), 프로세스는 페이지(Page)라 불리는 고정 크기의 블록(Block)으로 분리된다.
  - 한 프로세스가 사용하는 공간은 여러 page로 나뉘어 관리되고, 각각의 page는 순서와 관계없이 메모리의 frame에 mapping 되어 저장된다. 
    - page들이 연속할 필요가 없어 외부 단편화를 해결할 수 있다.
    - 할당과 해제가 빠르다.
    - 코드를 쉽게 공유할 수 있다(Shared pages). 코드가 pure code라면 공유가 가능하며 read-only로 프로세스 간에 하나의 코드만 메모리에 올린다. 
    - 내부 단편화를 해결하지 못한다.
    - page table을 저장하기 위한 메모리가 추가로 소모된다.
    - page table이 메모리에 상주하기 때문에 메모리에 접근하는 연산은 2번의 메모리 접근이 필요하게 되어 속도가 느리다.
  
- **TLB**
  - 메모리 주소 변환을 위한 별도의 캐시 메모리로, page table에서 빈번히 참조되는 일부 엔트리를 caching 하고 있다.

- **Segmentation**
  - 의미 단위로 하나의 프로세스를 나누는 것을 말한다. 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.
  - 작게는 프로그램을 구성하는 함수 하나하나를, 크게는 프로그램 전체를 하나의 Segment로 정의할 수 있다. 일반적으로는 code, data, stack 부분이 하나의 세그먼트로 정의된다. 
    - segment들이 연속적으로 할당될 필요가 없고, stack과 heap이 독립적으로 커질 수 있으며, segment마다 protection을 따로 수행할 수 있는 등 paging과 유사한 장점
    - 각각의 segment는 반드시 연속적으로 할당해야 하는 단점

- **Paging, Segmentation 차이**
  - 페이징기법에서 가상메모리를 같은 크기의 단위로 분할했지만 세그멘테이션기법에서는 가상메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환을 하게 된다.
